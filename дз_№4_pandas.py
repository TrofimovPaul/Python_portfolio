# -*- coding: utf-8 -*-
"""ДЗ №4. Pandas.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ErHN2xaFlQG7F81Ov5ZbsPk6c3yCSYT1
"""

"""Задание 1

Для датафрейма log из материалов занятия создайте столбец source_type по следующим правилам:

    если источник traffic_source равен yandex или google, то в source_type ставится organic
    для источников paid и email из России - ставим ad
    для источников paid и email не из России - ставим other
    все остальные варианты берем из traffic_source без изменений

#df.loc[df.traffic_source in ['yandex', 'google'], 'source_type'] = 'organic'
df.loc[df.region == 'Russia',  'source_type'] = 'ad'
df.loc[df.region != 'Russia',  'source_type'] = 'other'

df['source_type'].value_counts()
df.tail()"""

import pandas as pd
df = pd.read_csv('visit_log.csv', sep = ';')
a = 0
def check1(p1, p2):
  global a
  if a != len(df):
    if p1 in ['yandex', 'google']:
      a += 1
      return 'organic'
    elif ((p1 == 'paid') | (p1 == 'email')) & (p2[a] == 'Russia'):
      a += 1
      return 'ad'
    elif ((p1 == 'paid') | (p1 == 'email')) & (p2[a] != 'Russia'):
      a += 1
      return 'other'
    else:
      a += 1
      return p1

df['source_type'] = df['traffic_source'].apply(check1, p2 = df.region)

df.tail()

#ОТВЕТЬТЕ, ПОЖАЛУЙСТА, ПОЧЕМУ В ДАННОМ СЛУЧАЕ ПРОГРАММА НЕ РАБОТАЕТ?

import pandas as pd
df1 = pd.read_csv('visit_log.csv', sep = ';')

for k in df1.region:
  
  print(k)



"""Задание 2

В файле URLs.txt содержатся url страниц новостного сайта. 
Вам необходимо отфильтровать его по адресам страниц с текстами новостей. 
Известно, что шаблон страницы новостей имеет внутри url следующую конструкцию: /, затем 8 цифр, затем дефис. 
Выполните следующие действия:

    Прочитайте содержимое файла с датафрейм
    Отфильтруйте страницы с текстом новостей, используя метод str.contains и регулярное выражение в соответствии с заданным шаблоном"""

df2 = pd.read_csv('URLs.txt', header = None)
df2.rename(columns = {0:'Url'}, inplace = True)
df2.head()
df2_filtered = df2[df2.Url.str.contains('.*/\d{8}-.*', regex = True)]
df2_filtered.head()

#Я СДАЮСЬ,  НЕ ПОНИМАЮ, КАК И ЧТО НУЖНО СДЕЛАТЬ, ЧТОБЫ ВЫВЕСТИ В ПАРУ-ТРОЙКУ ДЕЙСТВИЙ НУЖНЫЙ РЕЗУЛЬТАТ. В ИНТЕРНЕТЕ ИСКАЛ, ДОКУМЕНТАЦИЮ ЧИТАЛ, 
#ВОПРОС ПОНИМАЮ, НО СГРУППИРОВАТЬ НОРМАЛЬНО НЕ МОГУ. МОГ БЫ СДЕЛАТЬ ЭТО ЧЕРЕЗ SQL ЗАПРОС, НО ТАК БУДЕТ НЕЧЕСТНО. ПРОКОММЕНТИРУЙТЕ ПОЖАЛУЙСТА.
#UPD: СДЕЛАЛ КАК-ТО КРИВО-КОСО В СЛЕДУЮЩЕЙ ЯЧЕЙКЕ
"""Задание 3

    Используйте файл с оценками фильмов ml-latest-small/ratings.csv. 
    Посчитайте среднее время жизни пользователей, которые выставили более 100 оценок. 
    Под временем жизни понимается разница между максимальным и минимальным значением столбца timestamp для данного значения userId."""
df_new = pd.read_csv('ratings.csv')

def groupby_function(rate):
    return rate.timestamp.max() - rate.timestamp.min()

ts = rate[rate.userId == 1].groupby('userId').agg({'timestamp' : ['max','min']}).reset_index()
ts['diff'] = ts['timestamp']['max']-ts['timestamp']['min']
ts['rate'] = rate.groupby('userId').agg({'rating':'count'})
ts

df5 = df_new.groupby('userId').count().reset_index()
ts2 = pd.DataFrame({'userId': [] ,'difference': [], 'rating':[]})
ts2
for i in range(len(df5)):
  ts = rate[rate.userId == i+1].groupby('userId').agg({'timestamp' : ['max','min']}).reset_index()
  ts['diff'] = ts['timestamp']['max']-ts['timestamp']['min']
  ts['rate'] = rate.groupby('userId').agg({'rating':'count'})
  ts = ts.reset_index()
  ts2 = ts2.append({'userId': ts['userId'] ,'difference': ts['diff'], 'rating':ts['rate']}, ignore_index=True)
ts2.reset_index()
ts2['userId']

df3 = pd.read_csv('ratings.csv')
df3.head()

res = df3.groupby(['userId', 'timestamp']).agg({'rating':'count'})

res = res.reset_index()
res = res.groupby('userId').agg({'timestamp':['max','min'],'rating':'count'}).reset_index()


res['difference'] = res['timestamp']['max']-res['timestamp']['min']


res.columns = res.columns.map(''.join)

res_new = res[['userId', 'ratingcount', 'difference']].query(f'ratingcount>100')
res_new['meandifference'] = int(mean(res_new['difference']))
res_new.sort_values(by = 'difference').head(10)

"""Задание 4

    Дана статистика услуг перевозок клиентов компании по типам (см. файл “Python_13_join.ipynb” в разделе Материалы для лекции «Продвинутый pandas» ---- Ноутбуки к лекции «Продвинутый pandas»).
    Необходимо сформировать две таблицы:

    таблицу с тремя типами выручки для каждого client_id без указания адреса клиента
    аналогичную таблицу по типам выручки с указанием адреса клиента

Обратите внимание, что в процессе объединения таблиц данные не должны теряться."""
rzd = pd.DataFrame(
    {
        'client_id': [111, 112, 113, 114, 115],
        'rzd_revenue': [1093, 2810, 10283, 5774, 981]
    }
)
rzd

auto = pd.DataFrame(
    {
        'client_id': [113, 114, 115, 116, 117],
        'auto_revenue': [57483, 83, 912, 4834, 98]
    }
)
auto

air = pd.DataFrame(
    {
        'client_id': [115, 116, 117, 118],
        'air_revenue': [81, 4, 13, 173]
    }
)
air

client_base = pd.DataFrame(
    {
        'client_id': [111, 112, 113, 114, 115, 116, 117, 118],
        'address': ['Комсомольская 4', 'Энтузиастов 8а', 'Левобережная 1а', 'Мира 14', 'ЗЖБИиДК 1', 
                    'Строителей 18', 'Панфиловская 33', 'Мастеркова 4']
    }
)
client_base

table2 = client_base.merge(air, how = 'left')
table2 = table2.merge(auto, how = 'left')
table2 = table2.merge(rzd, how = 'left').fillna(0)

table1 = table2[['client_id','air_revenue', 'auto_revenue', 'rzd_revenue']]

print('ТАБЛИЦА №1\n',table1,'\n\nТАБЛИЦА №2\n', table2)