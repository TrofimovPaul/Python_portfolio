# -*- coding: utf-8 -*-
"""ДЗ№3 Статистика.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13YppB44zzZBfmhOqFyhomkII9ULkC3M8
"""

"""
Смоделировать игру против лотерейного автомата типа “777”. Игрок платит 1 руб., 
после чего выпадает случайное целое число, равномерно распределенное от 0 до 999.
При некоторых значениях числа игрок получает выигрыш.

777: 200 руб.
999: 100 руб.
555: 50 руб.
333: 15 руб.
111: 10 руб.
*77: 5 руб.
**7: 3 руб.
*00: 2 руб.
**0: 1 руб.

Выгодна ли игра игроку? 
Сколько в среднем приобретает или теряет игрок за одну игру?

Дополнительное задание повышенной сложности. 
Теоретически рассчитать средний выигрыш (проигрыш) и сравнить с результатами моделирования
"""

import numpy as np
import re
listsum = []
listwins = []
listloses = []

#Шаблоны для проверки
pattern_1 = r'\d77'
pattern_2 = r'\d\d7'
pattern_3 = r'\d00'
pattern_4 = r'\d\d0'


#НЕ ВСТАВИЛ СЮДА 000, ТАК КАК НЕТ ТОЧНОГО ПОРЯДКА ДЕЙСТВИЙ ПРИ ВЫПАДЕНИИ ДАННОГО ЧИСЛА

#Запись в список значений от 1 до 999 в формате 000
list_string = []
for i in range(1, 1000):
  if len(str(i)) == 1:
    list_string.append('00'+str(i))
  elif len(str(i)) == 2:
    list_string.append('0'+str(i))
  else:
    list_string.append(str(i))

#Перевод списка в строку для поиска значений
str_to_find = ','.join(list_string)

#Поиск по шаблонам и вывод значений в списки
lp1 = re.findall(pattern_1, str_to_find)

lp2 = re.findall(pattern_2, str_to_find)
  #Фильтрация значений в lp2
lp2 = sorted(list(set(lp2) - set(lp1)))

lp3 = re.findall(pattern_3, str_to_find)

lp4 = re.findall(pattern_4, str_to_find)
  #Фильтрация значений в lp2
lp4 = sorted(list(set(lp4) - set(lp3)))


#Словарь {число: сумма выигрыша}
dict_of_triples = {111: 10, 333: 15, 555: 50, 777: 200, 999: 100}

lp1 = [int(i) for i in lp1]
#print(lp1)
lp2 = [int(i) for i in lp2]
#print(lp2)
lp3 = [int(i) for i in lp3]
#print(lp3)
lp4 = [int(i) for i in lp4]
#print(lp4)
def lucky():
  tries = 1000000
  sum_of_wins = 0
  count_of_loses = 0
  count_of_wins = 0
  for i in range(tries):
    lot = np.random.randint(0, 1000, 1)
    if lot[0] in dict_of_triples.keys():
      sum_of_wins += dict_of_triples[lot[0]]
      count_of_wins += 1
    elif lot[0] in lp1:
      sum_of_wins += 5
      count_of_wins += 1
    elif lot[0] in lp2:
      sum_of_wins += 3
      count_of_wins += 1
    elif lot[0] in lp3:
      sum_of_wins += 2
      count_of_wins += 1
    elif lot[0] in lp4:
      sum_of_wins += 1
      count_of_wins += 1 
    else:
      count_of_loses += 1
  listsum.append(sum_of_wins/tries*100)
  listwins.append(count_of_wins/tries*100)
  listloses.append(count_of_loses/tries*100)
  return print('Сумма выигрыша:', sum_of_wins,'\nСумма проигрыша:', tries - sum_of_wins,'\nКоличество выигрышей:', count_of_wins,'\nКоличество проигрышей:', count_of_loses)

#Процент выигрышей находится в пределах 20 %, сумма выигрыша находится в пределах 79-81 % от общей потраченной суммы. Исходя из этого, можно заключить, что игра не будет выгодной для игрока.

tr = 10
while tr != 0:
  lucky()
  tr -= 1

#Дополнительное задание повышенной сложности. 
#Теоретически рассчитать средний выигрыш (проигрыш) и сравнить с результатами моделирования
#Количество всех чисел
all_lots = 1000

#Количество выигрышных чисел
all_wins = len(set(lp1 + lp2 + lp3 + lp4)) + len(dict_of_triples)
print('Процент выигрыша теоретический:', round(all_wins/all_lots*100, 2),'%')
#Количество проигрышных чисел
all_loses = all_lots - all_wins
print('Процент проигрыша теоретический:', round(all_loses/all_lots*100, 2),'%')

listsum = [round(x, 3) for x in listsum]
listwins = [round(x, 3) for x in listwins]
listloses = [round(x, 3) for x in listloses]
print('Сумма выигрыша в зависимости от запуска программы: ', listsum)
print('Процент выигрыша в зависимости от запуска программы: ', listwins)
print('Процент проигрыша в зависимости от запуска программы: ', listloses)

import matplotlib.pyplot as plt
import pandas as pd
plt.plot(listwins)
plt.axis([0, 15, 18, 22])
plt.xlabel('Номер проверки')
plt.ylabel('Процент выигрыша')
plt.title('Динамика процента выигрыша')
plt.show()

"""СООБЩЕНИЕ В СЛЭКЕ

Добрый день, Олег!
Павел, приветствую!
Спасибо, у вас верный подход к моделированию, но есть пара неточностей, которые сильно искажают результат:
вы почему-то не предусматриваете выпадение 000;
По поводу дз №3 по статистике, а как 000 должно предусматриваться? В данных нет точного описания действий при выпадении такого числа.
*00: 2 руб.
**0: 1 руб.
Это либо 1 руб., либо 2руб., либо 1+2 рубля? В списках проверок у меня исключено значение с тремя нулями:
pattern_3 = r'\d00'
pattern_4 = r'\d\d0'
Я принял, что при 000 игрок ничего не получает
я бы рекомендовал увеличить количество испытаний, чтобы “стабилизировать” результат. При миллионе мы уже будем получать расчетную частоту максимально приближенную к теоретической. При вашем количестве испытаний будет сильный разброс (чем больше разных исходов, тем больше нужно испытаний для максимального приближения частоты к вероятности);
данное количество испытаний я взял, чтобы не ждать долго наполнения списка listwins и listloses. Даже при 100000 вероятность уже не прыгает туда-сюда.
совсем не обязательно накапливать все выигрыши в списке, нам ведь нужна только их сумма. Можно было создать не список, а инициализировать переменную нулем и именно к ней прибавлять все выигрыши. Это значительно бы ускорило исполнение кода.
тут не понял немного. Список у меня сделан был просто ,чтобы смотреть динамику суммы выигрыша в зависимости от запуска программы. По факту всё суммируется в  sum_of_wins
tries = 10000
sum_of_wins = 0                          < --- тут
count_of_loses = 0
count_of_wins = 0
for i in range(tries):
  lot = np.random.randint(0, 1000, 1)
  if lot[0] in lp1:
    sum_of_wins += 5
    count_of_wins += 1
  elif lot[0] in lp2:
    sum_of_wins += 3
    count_of_wins += 1
  elif lot[0] in lp3:
    sum_of_wins += 2
    count_of_wins += 1
  elif lot[0] in lp4:
    sum_of_wins += 1
    count_of_wins += 1
  elif lot[0] in dict_of_triples.keys():
    sum_of_wins += dict_of_triples[lot[0]]
    count_of_wins += 1
  else:
    count_of_loses += 1"""

